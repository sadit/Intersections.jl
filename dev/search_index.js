var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"\nCurrentModule = Intersections\nDocTestSetup = quote\n    using Intersections\nend","category":"page"},{"location":"api/#Intersection-algorithms","page":"API","title":"Intersection algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"bk\nbaezayates\nsvs\nimerge2","category":"page"},{"location":"api/#Intersections.baezayates","page":"API","title":"Intersections.baezayates","text":"baezayates(A, B, output=eltype(A)[], findpos=binarysearch)\n\nComputes the intersection between first and second ordered lists using the Baeza-Yates algorithm [cite]. The intersection is stored in output.\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.svs","page":"API","title":"Intersections.svs","text":"svs(postinglists, intersect2=baezayates)\n\nComputes the intersection of the ordered lists in postinglists using a small vs small strategy. Accepts an intersection algorithm of two sets.\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.imerge2","page":"API","title":"Intersections.imerge2","text":"imerge2(A, B, output=eltype(A)[])\n\nComputes the intersection of A and B (sorted arrays), using a merge-like algorithm, and stores it in output.\n\n\n\n\n\n","category":"function"},{"location":"api/#Union-algorithms","page":"API","title":"Union algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"umerge","category":"page"},{"location":"api/#Searching-algorithms","page":"API","title":"Searching algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"binarysearch\ndoublingsearch\ndoublingsearchrev\nseqsearch\nseqsearchrev","category":"page"},{"location":"api/#Intersections.binarysearch","page":"API","title":"Intersections.binarysearch","text":"binarysearch(A, x, sp=1, ep=length(A))\n\nFinds the insertion position of x in A in the range sp:ep\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.doublingsearch","page":"API","title":"Intersections.doublingsearch","text":"doublingsearch(A, x, sp=1, ep=length(A))\n\nFinds the insertion position of x in A, starting at sp\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.doublingsearchrev","page":"API","title":"Intersections.doublingsearchrev","text":"doublingsearchrev(A, x, sp=1, ep=length(A))\n\nFinds the insertion position of x in A, starting at the end\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.seqsearch","page":"API","title":"Intersections.seqsearch","text":"searchrev(A, x, sp=1, ep=length(A))\n\nSequential search, i.e., it starts from sp to ep\n\n\n\n\n\n","category":"function"},{"location":"api/#Intersections.seqsearchrev","page":"API","title":"Intersections.seqsearchrev","text":"seqsearchrev(A, x, sp=1, ep=length(A))\n\nReverse sequential search, i.e., it starts from ep to sp\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Intersections","category":"page"},{"location":"#Intersections.jl","page":"Home","title":"Intersections.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Intersections.jl is a library for computing intersections for sets represented as sorted lists. It also implements some union algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"bk: (Barbay & Kenyon-Mathieu) algorithm, for k sets\nbaezayates: (Baeza-Yates) intersection algorithm, for two sets\nsvs: small vs small strategy for k sets, it follows a parametric approach on the 2-set intersection problem.\nimerge2: Intersection using a merge-like algorithm for two sets\numerge: union algorithm based on merge, for k sets","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some algorithms are also parametric on the accepted search algorithm. In particular, this package also provides a few search algorithms","category":"page"},{"location":"","page":"Home","title":"Home","text":"binarysearch: typical bounded binary search \ndoublingsearch: unbounded search (galloping) (expects the insertion position near to starting point)\ndoublingsearchrev: idem. but galloping from right to left (expects the insertion position be close to the end position)\nseqsearch: sequential search\nseqsearchrev: reverse sequential search","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, bk and umerge can be used along with callbacks to avoid storing output sets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[TODO] Add proper references","category":"page"}]
}
